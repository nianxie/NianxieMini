
local loaded, packages, require_ = {}, {}, require

local function require(path)
    if loaded[path] then
        return loaded[path]
    elseif packages[path] then
        loaded[path] = packages[path](path)
        return loaded[path]
    else
        return require_(path)
    end
end

--boot.Exception begin ==========(
do local _ENV = _ENV
packages['boot.Exception'] = function (...)

local Exception = {}
Exception.__index = Exception

function Exception.new(vReason, vStack)
    return setmetatable({
        reason=vReason,
        stack=vStack,
    }, Exception)
end

function Exception:__tostring()
    return "Exception:"..tostring(self.reason).."\n"..tostring(self.stack)
end

function Exception.is(v)
    return getmetatable(v) == Exception
end

return Exception

end end
--boot.Exception end ==========)

--boot.Future begin ==========(
do local _ENV = _ENV
packages['boot.Future'] = function (...)

local Exception = require "boot.Exception"

local Future = {}
local FutureVtbl = {}
local FutureMeta = {
    __index=FutureVtbl
}

local MainThreadCall = nil  

      
local PENDING = 0
local REJECTED = 1
local RESOLVED = 2

local function xerror(excOrReason)
         
    return Exception.is(excOrReason) and excOrReason or Exception.new(excOrReason, debug.traceback(nil, 2))
end

function Future.new(vSyncFn)
       
         
    
         
    

    local self = setmetatable({
        __type = false  ,
        _stack = debug.traceback(nil, 2),
        _state = PENDING    ,
        _value = nil  ,
        _exception = nil  ,
         
        _thread = false  ,
         
        _cbList = false    ,
         
        _coList = false  ,
    }, FutureMeta)
    if vSyncFn then
        local co = coroutine.create(function(syncFn)
            local ok, ret = xpcall(syncFn, xerror)
            MainThreadCall(function()
                Future.complete(self, ok, ret)
            end)
        end)
        self._thread = co
        local ok, err = coroutine.resume(co, vSyncFn)
        if not ok then
            print("ERROR when task start:", err)
        end
    end
    return self
end

function Future.initHelper(vAsyncHelper)
    MainThreadCall = function(fn)
        vAsyncHelper:Call(fn)
    end
end

function Future.is(v)
    return getmetatable(v) == Future
end

function Future.complete(self, ok, ret)
    if ok then
        self._state = RESOLVED
        self._value = ret  
    else
        ret = Exception.is(ret) and ret or Exception.new(ret  , self._stack)
        self._state = REJECTED
        self._exception = ret  
    end
    local coList = self._coList
    self._coList = false
    if coList then
        for i=1,#coList do
            local co = coList[i]
            local ok1, err = coroutine.resume(co, ok, ret)
            if not ok1 then
                print("ERROR when task complete:", err)
            end
        ::continue:: end
    end
    local cbList = self._cbList
    self._cbList = false
    if cbList then
        for i=1,#cbList do
            local cb = cbList[i]
            local ok1, err = pcall(cb, ok, ret)
            if not ok1 then
                print("ERROR when task complete:", err)
            end
        ::continue:: end
    end
    if not ok then
        print("ERROR: forget error:", tostring(ret))
    end
end

function FutureVtbl:pwait()  
    local co, ismain = coroutine.running()
    assert(not ismain, "can't wait in main coroutine")
    if self._state == PENDING then
        local coList = self._coList
        if not coList then
            self._coList = {co}
        else
            coList[#coList + 1] = co
        end
        local ok, ret = coroutine.yield()
        if not ok then
            return false, ret
        else
            return true, ret  
        end
    else
        if self._state == REJECTED then
            return false, self._exception
        elseif self._state == RESOLVED then
            return true, self._value  
        end
    end
end

function FutureVtbl:wait()
    local ok, ret = self:pwait()
    if ok then
        return ret
    else
        error(ret)
    end
end

function FutureVtbl:callback(onSuccess, onFail)
    local callback = function(succ, result )
        if succ then
            local ok, ret = xpcall(onSuccess, xerror, result)
            if not ok then
                print("ERROR: callback", ret)
            end
        else
            if onFail then
                local ok, ret = xpcall(onFail, xerror, result)
                if not ok then
                    print("ERROR: callback", ret)
                end
            else
                print("ERROR: forget error", result)
            end
        end
    end
    local state = self._state
    if state ~= PENDING then
        MainThreadCall(function()
            if state == RESOLVED then
                callback(true, self._value  )
            elseif state == REJECTED then
                callback(false, self._exception  )
            end
        end)
    else
        local cbList = self._cbList
        if not cbList then
            self._cbList = {callback}
        else
            cbList[#cbList + 1] = callback
        end
    end
end

function FutureVtbl:isPending()
    return self._state == PENDING
end

function FutureVtbl:isResolved()
    return self._state == RESOLVED
end

function FutureVtbl:isRejected()
    return self._state == REJECTED
end

return Future

end end
--boot.Future end ==========)

--boot.Stream begin ==========(
do local _ENV = _ENV
packages['boot.Stream'] = function (...)

local Exception = require "boot.Exception"

local Stream = {}
local StreamVtbl = {}
local StreamMeta = {
    __index=StreamVtbl
}

local MainThreadCall = nil  

local function xerror(excOrReason)
         
    return Exception.is(excOrReason) and excOrReason or Exception.new(excOrReason, debug.traceback(nil, 2))
end

function Stream.new(vSyncFn)
       
         
    
         
    

    local self = setmetatable({
        __type = false  ,
        _closed = false  ,
         
        _thread = false  ,
         
        _coList = false  ,
    }, StreamMeta)
    if vSyncFn then
        local co = coroutine.create(function(syncFn)
            local ok, ret = xpcall(syncFn, xerror)
        end)
        self._thread = co
        local ok, err = coroutine.resume(co, vSyncFn)
        if not ok then
            print("ERROR when stream start:", err)
        end
    end
    return self
end

function Stream.initHelper(vAsyncHelper)
    MainThreadCall = function(fn)
        vAsyncHelper:Call(fn)
    end
end

function Stream.is(v)
    return getmetatable(v) == Stream
end

function Stream.sink(self, ok, ret)
end

function StreamVtbl:pnext();  
    error("stream pnext TODO")
    return false, nil
end

function StreamVtbl:next();
    error("stream next TODO")
    return nil  
end

local next = function(stream)
    return stream:next()
end

function StreamVtbl:iter()
    return next, self
end

return Stream

end end
--boot.Stream end ==========)

--boot.boot begin ==========(
do local _ENV = _ENV
packages['boot.boot'] = function (...)

local Future = require "boot.Future"
local Stream = require "boot.Stream"

;
	


local boot = {}

function boot.Repl(script)
	local func, err = load('return '..script, '(lua repl)')
	if not func then
			func, err = load(script, '(lua repl)')
	end
	if not func then
			print(err)
	else
		local function evalprint(ok, ...)
				if ok and (select('#', ...) >= 1) then
						print(...)
				end
		end
		evalprint(xpcall(func, function(e)
				print(e, debug.traceback())
		end))
	end
end


function boot.InitHelper(vAsyncHelper)
	Future.initHelper(vAsyncHelper)
	Stream.initHelper(vAsyncHelper)
end

   
boot.NewFuture=Future.new

boot.NewStream=Stream.new

function boot.Sleep(asyncHelper, ms)
	return asyncHelper:FutureSleep(ms):wait()
end

boot.CompleteFuture = Future.complete
boot.SinkStream = Stream.sink

boot.rapidjsonDecode = require "rapidjson".decode

return boot


end end
--boot.boot end ==========)

--reflect.behav.LuaScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.LuaScript'] = function (...)


local class = require  "reflect.class"

local LuaScript = class (false)

function LuaScript:ctor()
    error("constructor function is implemented by LuaBehaviour in csharp")
end

return LuaScript
end end
--reflect.behav.LuaScript end ==========)

--reflect.behav.MiniScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.MiniScript'] = function (...)


local class = require  "reflect.class"
local LuaScript = require "reflect.behav.LuaScript"

local MiniScript = class (LuaScript)
MiniScript.meta.__behavType = typeof(CS.Nianxie.Components.MiniBehaviour)

return MiniScript
end end
--reflect.behav.MiniScript end ==========)

--reflect.behav.SlotScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.SlotScript'] = function (...)


local class = require  "reflect.class"
local LuaScript = require "reflect.behav.LuaScript"

local SlotScript = class (LuaScript)
SlotScript.meta.__behavType = typeof(CS.Nianxie.Craft.SlotBehaviour)

return SlotScript
end end
--reflect.behav.SlotScript end ==========)

--reflect.class begin ==========(
do local _ENV = _ENV
packages['reflect.class'] = function (...)

local ClassCore = require  "reflect.injection.ClassCore"

return ClassCore.class
end end
--reflect.class end ==========)

--reflect.injection.ClassCore begin ==========(
do local _ENV = _ENV
packages['reflect.injection.ClassCore'] = function (...)

local meta2isCache={}

;
	  
	  
	  
	  
	  


local function recursiveCreate(obj, cls, ...)
	local super = cls.super
	if super then
		recursiveCreate(obj, super, ...)
	end
	local ctor = cls.ctor
	if ctor then
		ctor(obj, ...)
	end
end

local classMeta = {
    __index=function(self,k)
        return self.meta.__index[k]
    end,
    __newindex=function(self,k,v)
        if type(v) == "function" then
            self.meta.__index[k]=v
        else
            rawset(self,k,v)
        end
    end,
    __name="class",
}

local function class (super)
	local classOpen={}
	local vtbl={}
	local meta={
		__index=vtbl,
		__class=classOpen,
		__behavType=super and super.meta.__behavType or false,
		__injections={}  ,
	}
	;
	classOpen.super=super or false
	classOpen.meta=meta
	classOpen.ctor=false
	classOpen.new=function (...)  
		local obj={}
		recursiveCreate(obj, classOpen, ...)
		setmetatable(obj, meta)
		return obj
	end
	classOpen.is=function(v)
		local isCache = meta2isCache[getmetatable(v) or 1]
		return isCache and isCache[classOpen] or false
	end
	classOpen.__hint=nil  
	local isCache = (setmetatable({}, {
		__index=function(type2is , if_type)
			local cur_type = classOpen
			while cur_type do
				if cur_type == if_type then
					type2is[if_type] = true
					return true
				else
					cur_type = cur_type.super
				end
			::continue:: end
			type2is[if_type] = false
			return false
		end
	}) );  
	meta2isCache[meta]=isCache

	setmetatable(classOpen,classMeta)

	if super then
		local super_meta = super.meta
		for k,v in pairs(super_meta.__index) do
			vtbl[k] = v
		::continue:: end
		 
		    
			            
				  
			
		
		
	end

	return classOpen
end

return {
    class=class,
	meta=classMeta,
}

end end
--reflect.injection.ClassCore end ==========)

--reflect.injection.LuafabField begin ==========(
do local _ENV = _ENV
packages['reflect.injection.LuafabField'] = function (...)

;
      


local LuafabField = {}
LuafabField.__index=LuafabField

function LuafabField.new (vClsOpen, vClsPath, vLazy)
       
         
    
          
    

    return setmetatable({
        clsOpen = vClsOpen,
        assetPath = vClsPath:gsub("[.]", "/")..".prefab",
        lazy = vLazy,
    }, LuafabField)
end

function LuafabField.is(v) 
    return getmetatable(v) == LuafabField
end

;
      
           
           
            
        
         
               
        
    

      
           
           
            
        
         
               
        
         
               
        
    

     
           
           
            
               
               
        
    


return LuafabField
end end
--reflect.injection.LuafabField end ==========)

--reflect.injection.ReflectInjection begin ==========(
do local _ENV = _ENV
packages['reflect.injection.ReflectInjection'] = function (...)

local LuafabField = require "reflect.injection.LuafabField"
local TableField = require "reflect.injection.TableField"

local typeof_LuaBehaviour = typeof(CS.Nianxie.Components.LuaBehaviour)
local typeof_LuafabLoading = typeof(CS.Nianxie.Framework.LuafabLoading)

local ClassCore = require "reflect.injection.ClassCore"

;
      


local ReflectInjection = {}

function ReflectInjection.new(vKey, vClsOpen, vCSharpType, vIndexCSharpType, vNodePath, vAssetPath, vNodePathTable , vAssetPathTable )
       
         
    
         
    

    return {
        key=vKey,
        clsOpen=vClsOpen,
        nodePath=vNodePath,
        assetPath=vAssetPath,
        nodePathTable=vNodePathTable,
        assetPathTable=vAssetPathTable,
        lazy=false,
        table=false,
        indexType=vIndexCSharpType,
        csharpType=vCSharpType,
        __injectionType=nil,
    }
end

function ReflectInjection.compare(vLeftInjection, vRightInjection)
    return vLeftInjection.key < vRightInjection.key
end

local function recursiveEvalNodePath(vNodePath , vKeyToFieldDefine    , vDepth)
    if vDepth > 5 then
        print("ERROR: node path eval $ too deep : "..tostring(vNodePath))
        return "?"
    end
    if vNodePath then
        local ret = vNodePath:gsub("^[$]([^/]+)", function(key)
            local fieldDefine = vKeyToFieldDefine[key]
            if not fieldDefine then
                return "$"..key
            end
            return recursiveEvalNodePath(fieldDefine[2], vKeyToFieldDefine, vDepth + 1) or "?"
        end)
        return ret
    else
        return nil
    end
end

function ReflectInjection.Create(vKeyToTuple, vKey, vFieldOrTuple)
    local outMeta = getmetatable(vFieldOrTuple)
    local fieldValue = outMeta and vFieldOrTuple or vFieldOrTuple[1]
    local nodePath=nil
    local assetPath=nil
    local nodePathTable=nil 
    local assetPathTable=nil 
    if not outMeta then
        if type(vFieldOrTuple) == "table" then
            do
                local tuple2 = vFieldOrTuple[2]
                local tuple3 = vFieldOrTuple[3]
                if type(tuple2) == "string" then
                    tuple2 = recursiveEvalNodePath(tuple2, vKeyToTuple, 1)
                elseif type(tuple2) == "table" then
                    for k,v in pairs(tuple2) do
                        tuple2[k] = recursiveEvalNodePath(v, vKeyToTuple, 1)
                    ::continue:: end
                end
                if type(tuple2) == "table" then
                    nodePathTable = tuple2
                else
                    nodePath = tuple2
                end
                if type(tuple3) == "table" then
                    assetPathTable = tuple3
                else
                    assetPath = tuple3
                end
            end
        else
            error("tuple not allow here")
        end
    end
    local valueMeta = getmetatable(fieldValue)
    if LuafabField.is(fieldValue) then
        local injection = ReflectInjection.new(vKey, fieldValue.clsOpen, typeof_LuafabLoading, nil, nil, fieldValue.assetPath)
        injection.lazy = fieldValue.lazy
        return injection
    elseif TableField.is(fieldValue) then
        local clsOpen, csharpType = ReflectInjection.checkClsOpenAndCSharpType(fieldValue.value)
        local key = fieldValue.key
        local injection = ReflectInjection.new(vKey, clsOpen, csharpType, key and typeof(key), nodePath, assetPath, nodePathTable, assetPathTable)
        injection.table = true
        return injection
    else
        local clsOpen, csharpType = ReflectInjection.checkClsOpenAndCSharpType(fieldValue, valueMeta)
        if clsOpen then
            local injection = ReflectInjection.new(vKey, clsOpen, csharpType, nil, nodePath, assetPath)
            return injection
        else
            return ReflectInjection.new(vKey, nil, csharpType, nil, nodePath, assetPath)
        end
    end
end

function ReflectInjection.checkClsOpenAndCSharpType(fieldValue, fieldMeta)
    local fieldMeta = fieldMeta or getmetatable(fieldValue)
    if ClassCore.meta == fieldMeta then
        local behavType = fieldValue.meta.__behavType
        if not behavType then
            error("lua class not match a behav type, maybe use MiniScript")
        else
            return fieldValue, behavType
        end
    else
        local ok, csharpType = pcall(typeof, fieldValue)
        if not ok then
            error("type expected:"..csharpType)
        else
            return nil, csharpType
        end
    end
end


return ReflectInjection
end end
--reflect.injection.ReflectInjection end ==========)

--reflect.injection.TableField begin ==========(
do local _ENV = _ENV
packages['reflect.injection.TableField'] = function (...)

;
      


local TableField = {}
TableField.__index=TableField

;
      
         
            
            
         
    


function TableField.new (vValue, vKey)
     

    return setmetatable({
        key=vKey,
        value=vValue,
    }, TableField)
end

function TableField.is(v)
    return getmetatable(v) == TableField
end

;
     
          
              
        
             
        
    


return TableField
end end
--reflect.injection.TableField end ==========)

--reflect.reflect begin ==========(
do local _ENV = _ENV
packages['reflect.reflect'] = function (...)

if false then 
	  
	 
	local rapidjson = require "rapidjson"
    local arraymeta = getmetatable(rapidjson.array())
    local objectmeta = getmetatable(rapidjson.object())
    local unsafearray = rapidjson.array
    rapidjson.array = function(t)
        if getmetatable(t) == objectmeta then
            return setmetatable(t, arraymeta)
        else
            return unsafearray(t)
        end
    end
    local unsafeobject = rapidjson.object
    rapidjson.object = function(t)
        if getmetatable(t) == arraymeta then
            return setmetatable(t, objectmeta)
        else
            return unsafeobject(t)
        end
    end
end

local class = require  "reflect.class"

local ReflectInjection = require "reflect.injection.ReflectInjection"
local LuafabField = require "reflect.injection.LuafabField"
local TableField = require "reflect.injection.TableField"

local reflect = {}
reflect.class = class

;
      
            
            
            
            
            
    
       
             
                
                  
            
                     
                  
            
        
    


local MiniScript = require "reflect.behav.MiniScript"
local SlotScript = require "reflect.behav.SlotScript"


function reflect._saveInjections(vClsOpen, vKeyToInjectionValue)
    local nInjectionList = vClsOpen.meta.__injections
    for nKey, nInjectionValue in pairs(vKeyToInjectionValue) do
        local nInjection = ReflectInjection.Create(vKeyToInjectionValue, nKey, nInjectionValue)
        nInjectionList[#nInjectionList + 1] = nInjection
    ::continue:: end
    table.sort(nInjectionList, ReflectInjection.compare)
end

function reflect.MiniScript (vKeyToInjectionValue)
    local clsOpen = class   (MiniScript)
    reflect._saveInjections(clsOpen, vKeyToInjectionValue)
    ;
          
               
             
               
            
             
                
              
                
            
        
    
    return clsOpen
end

function reflect.SlotScript (vKeyToInjectionValue)
    local clsOpen = class   (SlotScript)
    reflect._saveInjections(clsOpen, vKeyToInjectionValue)
    ;
          
               
             
               
            
             
        
    
    return clsOpen
end

function reflect.lazyLuafab(clsPath)
    local clsOpen = require(clsPath)
    return LuafabField.new (clsOpen, clsPath, true)
end

function reflect.readyLuafab(clsPath)
    local clsOpen = require(clsPath)
    return LuafabField.new (clsOpen, clsPath, false)
end

function reflect.Dict(key, value)
    return TableField.new (value, key)
end

function reflect.List(value)
    return TableField.new (value, nil)
end

function reflect.Any()
    return nil
end

return reflect

end end
--reflect.reflect end ==========)

package.preload["reflect.reflect"] = packages["reflect.reflect"]
package.preload["reflect.class"] = packages["reflect.class"]
package.preload["reflect"] = function()
    return require "reflect.reflect"
end
package.preload["class"] = function()
    return require "reflect.class"
end
return packages["boot.boot"]()
