
local loaded, packages, require_ = {}, {}, require

local function require(path)
    if loaded[path] then
        return loaded[path]
    elseif packages[path] then
        loaded[path] = packages[path](path)
        return loaded[path]
    else
        return require_(path)
    end
end

--boot.Exception begin ==========(
do local _ENV = _ENV
packages['boot.Exception'] = function (...)

local Exception = {}
Exception.__index = Exception

function Exception.new(vReason, vStack)
    return setmetatable({
        reason=vReason,
        stack=vStack,
    }, Exception)
end

function Exception:__tostring()
    return "Exception:"..tostring(self.reason).."\n"..tostring(self.stack)
end

function Exception.is(v)
    return getmetatable(v) == Exception
end

return Exception

end end
--boot.Exception end ==========)

--boot.Future begin ==========(
do local _ENV = _ENV
packages['boot.Future'] = function (...)

local Exception = require "boot.Exception"

local Future = {}
local FutureVtbl = {}
local FutureMeta = {
    __index=FutureVtbl
}

local MainThreadCall = nil  

      
local PENDING = 0
local REJECTED = 1
local RESOLVED = 2

local function xerror(excOrReason)
         
    return Exception.is(excOrReason) and excOrReason or Exception.new(excOrReason, debug.traceback(nil, 2))
end

function Future.new(vSyncFn)
       
         
    
         
    

    local self = setmetatable({
        __type = false  ,
        _stack = debug.traceback(nil, 2),
        _state = PENDING    ,
        _value = nil  ,
        _exception = nil  ,
         
        _thread = false  ,
         
        _cbList = false    ,
         
        _coList = false  ,
    }, FutureMeta)
    if vSyncFn then
        local co = coroutine.create(function(syncFn)
            local ok, ret = xpcall(syncFn, xerror)
            MainThreadCall(function()
                Future.complete(self, ok, ret)
            end)
        end)
        self._thread = co
        local ok, err = coroutine.resume(co, vSyncFn)
        if not ok then
            print("ERROR when task start:", err)
        end
    end
    return self
end

function Future.initHelper(vAsyncHelper)
    MainThreadCall = function(fn)
        vAsyncHelper:Call(fn)
    end
end

function Future.is(v)
    return getmetatable(v) == Future
end

function Future.complete(self, ok, ret)
    if ok then
        self._state = RESOLVED
        self._value = ret  
    else
        ret = Exception.is(ret) and ret or Exception.new(ret  , self._stack)
        self._state = REJECTED
        self._exception = ret  
    end
    local coList = self._coList
    self._coList = false
    if coList then
        for i=1,#coList do
            local co = coList[i]
            local ok1, err = coroutine.resume(co, ok, ret)
            if not ok1 then
                print("ERROR when task complete:", err)
            end
        ::continue:: end
    end
    local cbList = self._cbList
    self._cbList = false
    if cbList then
        for i=1,#cbList do
            local cb = cbList[i]
            local ok1, err = pcall(cb, ok, ret)
            if not ok1 then
                print("ERROR when task complete:", err)
            end
        ::continue:: end
    end
    if not ok then
        print("ERROR: forget error:", tostring(ret))
    end
end

function FutureVtbl:pwait()  
    local co, ismain = coroutine.running()
    assert(not ismain, "can't wait in main coroutine")
    if self._state == PENDING then
        local coList = self._coList
        if not coList then
            self._coList = {co}
        else
            coList[#coList + 1] = co
        end
        local ok, ret = coroutine.yield()
        if not ok then
            return false, ret
        else
            return true, ret  
        end
    else
        if self._state == REJECTED then
            return false, self._exception
        elseif self._state == RESOLVED then
            return true, self._value  
        end
    end
end

function FutureVtbl:wait()
    local ok, ret = self:pwait()
    if ok then
        return ret
    else
        error(ret)
    end
end

function FutureVtbl:callback(onSuccess, onFail)
    local callback = function(succ, result )
        if succ then
            local ok, ret = xpcall(onSuccess, xerror, result)
            if not ok then
                print("ERROR: callback", ret)
            end
        else
            if onFail then
                local ok, ret = xpcall(onFail, xerror, result)
                if not ok then
                    print("ERROR: callback", ret)
                end
            else
                print("ERROR: forget error", result)
            end
        end
    end
    local state = self._state
    if state ~= PENDING then
        MainThreadCall(function()
            if state == RESOLVED then
                callback(true, self._value  )
            elseif state == REJECTED then
                callback(false, self._exception  )
            end
        end)
    else
        local cbList = self._cbList
        if not cbList then
            self._cbList = {callback}
        else
            cbList[#cbList + 1] = callback
        end
    end
end

function FutureVtbl:isPending()
    return self._state == PENDING
end

function FutureVtbl:isResolved()
    return self._state == RESOLVED
end

function FutureVtbl:isRejected()
    return self._state == REJECTED
end

return Future

end end
--boot.Future end ==========)

--boot.Stream begin ==========(
do local _ENV = _ENV
packages['boot.Stream'] = function (...)

local Exception = require "boot.Exception"

local Stream = {}
local StreamVtbl = {}
local StreamMeta = {
    __index=StreamVtbl
}

local MainThreadCall = nil  

local function xerror(excOrReason)
         
    return Exception.is(excOrReason) and excOrReason or Exception.new(excOrReason, debug.traceback(nil, 2))
end

function Stream.new(vSyncFn)
       
         
    
         
    

    local self = setmetatable({
        __type = false  ,
        _closed = false  ,
         
        _thread = false  ,
         
        _coList = false  ,
    }, StreamMeta)
    if vSyncFn then
        local co = coroutine.create(function(syncFn)
            local ok, ret = xpcall(syncFn, xerror)
        end)
        self._thread = co
        local ok, err = coroutine.resume(co, vSyncFn)
        if not ok then
            print("ERROR when stream start:", err)
        end
    end
    return self
end

function Stream.initHelper(vAsyncHelper)
    MainThreadCall = function(fn)
        vAsyncHelper:Call(fn)
    end
end

function Stream.is(v)
    return getmetatable(v) == Stream
end

function Stream.sink(self, ok, ret)
end

function StreamVtbl:pnext();  
    error("stream pnext TODO")
    return false, nil
end

function StreamVtbl:next();
    error("stream next TODO")
    return nil  
end

local next = function(stream)
    return stream:next()
end

function StreamVtbl:iter()
    return next, self
end

return Stream

end end
--boot.Stream end ==========)

--boot.boot begin ==========(
do local _ENV = _ENV
packages['boot.boot'] = function (...)

local Future = require "boot.Future"
local Stream = require "boot.Stream"

;
	


local boot = {}

function boot.Repl(script)
	local func, err = load('return '..script, '(lua repl)')
	if not func then
			func, err = load(script, '(lua repl)')
	end
	if not func then
			print(err)
	else
		local function evalprint(ok, ...)
				if ok and (select('#', ...) >= 1) then
						print(...)
				end
		end
		evalprint(xpcall(func, function(e)
				print(e, debug.traceback())
		end))
	end
end


function boot.InitHelper(vAsyncHelper)
	Future.initHelper(vAsyncHelper)
	Stream.initHelper(vAsyncHelper)
end

   
boot.NewFuture=Future.new

boot.NewStream=Stream.new

function boot.Sleep(asyncHelper, ms)
	return asyncHelper:FutureSleep(ms):wait()
end

boot.CompleteFuture = Future.complete
boot.SinkStream = Stream.sink

boot.rapidjsonDecode = require "rapidjson".decode

return boot


end end
--boot.boot end ==========)

--reflect.behav.ForView begin ==========(
do local _ENV = _ENV
packages['reflect.behav.ForView'] = function (...)

local class = require  "reflect.class"

local ForView = {}
ForView.__index = ForView

local FOR_NUM = 1
local FOR_RANGE = 2
local FOR_IN = 3

function ForView.ForNum(vParent)
    local self = {
        parent=vParent,
        keyToInst={}   ,
        kind=FOR_NUM,
        num=false,
        kvMaker=false 
    }
    function self:Setup(vProps 
        
        
    )
        self.num = vProps.num
        self.kvMaker = vProps.kvMaker
    end
    return setmetatable(self, ForView)
end

function ForView.ForRange(vParent)
    local self = {
        parent=vParent,
        keyToInst={}   ,
        kind=FOR_RANGE,
        range=false  ,
        kvMaker=false 
    }
    function self:Setup(vProps 
        
        
    )
        self.range = vProps.range
        self.kvMaker = vProps.kvMaker
    end
    return setmetatable(self, ForView)
end

function ForView.ForIn(vParent)
    local self = {
        parent=vParent,
        keyToInst={}   ,
        kind=FOR_IN,
        iter=false  ,
        kvMaker=false  
    }
    function self:Setup(vProps 
        
        
    )
        self.iter = vProps.iter
        self.kvMaker = vProps.kvMaker
    end
    return setmetatable(self, ForView)
end

function ForView:Refresh()
    local kind = self.kind
    local keyToInst = self.keyToInst
    local keySet = {}   
    for k in pairs(keyToInst) do
        keySet[k] = true
    ::continue:: end
    local kvMaker = self.kvMaker
    if kind == FOR_IN then
        for k,v in self.iter() do
            local key, maker = kvMaker(k,v)
            local obj = keyToInst[key]
            if not obj then
                obj = maker()
                keyToInst[key] = obj
            else
                keySet[key] = nil
            end
            obj:Refresh()
        ::continue:: end
    else
        local start, finish, step = 1,1,1
        if kind == FOR_NUM then
            finish = self.num()
        elseif kind == FOR_RANGE then
            start, finish, step = self.range()
            step = step or 1
        else
            error("unexpected branch when ForView:Refresh()")
        end
        for i=start, finish, step do
            local key, maker = kvMaker(i)
            local obj = keyToInst[key]
            if not obj then
                obj = maker()
                keyToInst[key] = obj
            else
                keySet[key] = nil
            end
            obj:Refresh()
        ::continue:: end
    end
    for key in pairs(keySet) do
        local obj = keyToInst[key]
        keyToInst[key] = nil
        UnityEngine.Object.Destroy(obj.gameObject)
    ::continue:: end
end

return ForView
end end
--reflect.behav.ForView end ==========)

--reflect.behav.LuaScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.LuaScript'] = function (...)


local class = require  "reflect.class"

local LuaScript = class (false)

function LuaScript:ctor()
    error("this function is replaced in reflect")
end

return LuaScript
end end
--reflect.behav.LuaScript end ==========)

--reflect.behav.MiniScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.MiniScript'] = function (...)


local class = require  "reflect.class"
local LuaScript = require "reflect.behav.LuaScript"

local MiniScript = class (LuaScript)

return MiniScript
end end
--reflect.behav.MiniScript end ==========)

--reflect.behav.ModuleScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.ModuleScript'] = function (...)


local class = require  "reflect.class"
local LuaScript = require "reflect.behav.LuaScript"

local ModuleScript = class (LuaScript)

function ModuleScript:ModuleInit(vShellContext)
end

return ModuleScript
end end
--reflect.behav.ModuleScript end ==========)

--reflect.behav.PanelScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.PanelScript'] = function (...)


local class = require "reflect.class"

local ViewScript = require "reflect.behav.ViewScript"

  
local PanelScript = class (ViewScript)

function PanelScript.ctor(self)
    self.__page = self
end

function PanelScript:setActive(vActive)
    self:setVisible(vActive)
end

function PanelScript:getPage()
    return self
end

return PanelScript
end end
--reflect.behav.PanelScript end ==========)

--reflect.behav.ViewScript begin ==========(
do local _ENV = _ENV
packages['reflect.behav.ViewScript'] = function (...)


local reflect = require  "reflect.reflect"
local class = reflect.class
local LuaScript = require "reflect.behav.LuaScript"
local ModuleScript = require "reflect.behav.ModuleScript"
local ForView = require "reflect.behav.ForView"

local ViewScript = class (LuaScript)

function ViewScript.ctor(self)
    self.gameObject = false ; 
    self.parent = false ; 
    self.this = false ; 
    self.transform = false ; 
    self.context = false ; 
    self.__refreshFn = false ; 
    self.__setuped = false ; 
    self.__page = false  
end

function ViewScript:_injectModule()
     
    local context = self.context
    local injections = getmetatable(self).__injections
    for i, injection in ipairs(injections) do
        local injectionClsOpen = injection.clsOpen
        if injectionClsOpen and injectionClsOpen.super == ModuleScript then
            self[injection.key] = self[injection.key] or context:getModule(injectionClsOpen)
        end
    ::continue:: end
end

local emptyFn = function() end
function ViewScript:Setup(vSetupProps )
    assert(not self.__setuped, "setup called more than once")
    self.__setuped = true
    do;
        self:_injectModule()
         
        self.props = vSetupProps
        local state = self:__stateFn(vSetupProps)
        self.state = state
        self.__refreshFn = self:build(vSetupProps, state) or emptyFn
        self:Refresh()
    end
    return self
end

function ViewScript:Refresh()
    assert(self.__setuped, "call Setup before Refresh")
    if self.gameObject:IsDestroyed() then
        print("WARNING gameobject is destroyed when Refresh", self.gameObject)
        return
    end
    local ok, err = xpcall(self.__refreshFn, function(err)
        return tostring(err) .."\n".. tostring(debug.traceback())
    end)
    if not ok then
        print("ERROR: Refresh error:", self.gameObject, err)
    end
end

function ViewScript:build(vProps, vState)
        
    return function()
          
    end
end

function ViewScript:setVisible(vVisible)
    if vVisible then
        if not self.gameObject.activeSelf then
            self.gameObject:SetActive(true)
        end
    else
        self.gameObject:SetActive(false)
    end
end

function ViewScript:Fork(vTrans)
    return self.this:Fork(vTrans).luaTable  
end

function ViewScript:getPage()
    local page = self.__page
    if not page then
        page = (self.parent  ):getPage()
        self.__page = page
    end
    return page
end

function ViewScript:ForNum()
    return ForView.ForNum(self)
end

function ViewScript:ForRange()
    return ForView.ForRange(self)
end

function ViewScript:ForIn()
    return ForView.ForIn(self)
end

local function Watcher(vGetter)
    local inited = false  
    local value = nil 
    local oldValue = nil 
    return function()  
        local newValue = vGetter()
        if not inited then
            inited = true
            oldValue = value
            value = newValue
            return true, value, oldValue
        elseif newValue ~= value then
            oldValue = value
            value = newValue
            return true, value, oldValue
        else
            return false, value, oldValue
        end
    end
end

function ViewScript:watch(vGetter)
    return Watcher(vGetter)
end

function ViewScript:watchProps() 
       
     

    local watchProps = self.__watchProps
    if not watchProps then
        watchProps = {}
        self.__watchProps = setmetatable(watchProps, {
            __index=function(t,k)
                local watcher = Watcher(self.props[k])
                watchProps[k] = watcher
                return watcher
            end
        })
    end
    return watchProps
end

function ViewScript:watchState() 
       
     
         
    

    local watchState = self.__watchState
    if not watchState then
        watchState = {}
        self.__watchState = setmetatable(watchState, {
            __index=function(t,k)
                local watcher = Watcher(function()
                    return self.state[k]
                end)
                watchState[k] = watcher
                return watcher
            end
        })
    end
    return watchState
end

return ViewScript
end end
--reflect.behav.ViewScript end ==========)

--reflect.class begin ==========(
do local _ENV = _ENV
packages['reflect.class'] = function (...)

local ClassCore = require  "reflect.injection.ClassCore"

return ClassCore.class
end end
--reflect.class end ==========)

--reflect.injection.ClassCore begin ==========(
do local _ENV = _ENV
packages['reflect.injection.ClassCore'] = function (...)

local meta2isCache={}

;
	  
	  
	  
	  
	  


local function recursiveCreate(obj, cls, ...)
	local super = cls.super
	if super then
		recursiveCreate(obj, super, ...)
	end
	local ctor = cls.ctor
	if ctor then
		ctor(obj, ...)
	end
end

local classMeta = {
    __index=function(self,k)
        return self.meta.__index[k]
    end,
    __newindex=function(self,k,v)
        if type(v) == "function" then
            self.meta.__index[k]=v
        else
            rawset(self,k,v)
        end
    end,
    __name="class",
}

local function class (super)
	local classOpen={}
	local vtbl={}
	local meta={
		__index=vtbl,
		__class=classOpen,
		__behavType=false,
		__injections={}  ,
	}
	;
	classOpen.super=super or false
	classOpen.meta=meta
	classOpen.ctor=false
	classOpen.new=function (...)  
		local obj={}
		recursiveCreate(obj, classOpen, ...)
		setmetatable(obj, meta)
		return obj
	end
	classOpen.is=function(v)
		local isCache = meta2isCache[getmetatable(v) or 1]
		return isCache and isCache[classOpen] or false
	end
	classOpen.__hint=nil  
	local isCache = (setmetatable({}, {
		__index=function(type2is , if_type)
			local cur_type = classOpen
			while cur_type do
				if cur_type == if_type then
					type2is[if_type] = true
					return true
				else
					cur_type = cur_type.super
				end
			::continue:: end
			type2is[if_type] = false
			return false
		end
	}) );  
	meta2isCache[meta]=isCache

	setmetatable(classOpen,classMeta)

	if super then
		local super_meta = super.meta
		for k,v in pairs(super_meta.__index) do
			vtbl[k] = v
		::continue:: end
		 
		    
			            
				  
			
		
		
	end

	return classOpen
end

return {
    class=class,
	meta=classMeta,
}

end end
--reflect.injection.ClassCore end ==========)

--reflect.injection.LuafabField begin ==========(
do local _ENV = _ENV
packages['reflect.injection.LuafabField'] = function (...)

;
      


local LuafabField = {}
LuafabField.__index=LuafabField

function LuafabField.new (vClsOpen, vClsPath, vLazy)
       
         
    
          
    

    return setmetatable({
        clsOpen = vClsOpen,
        assetPath = vClsPath:gsub("[.]", "/")..".prefab",
        lazy = vLazy,
    }, LuafabField)
end

function LuafabField.is(v) 
    return getmetatable(v) == LuafabField
end

;
      
           
           
            
        
         
               
        
    

      
           
           
            
        
         
               
        
         
               
        
    

     
           
           
            
               
               
        
    


return LuafabField
end end
--reflect.injection.LuafabField end ==========)

--reflect.injection.ReflectInjection begin ==========(
do local _ENV = _ENV
packages['reflect.injection.ReflectInjection'] = function (...)

local LuafabField = require "reflect.injection.LuafabField"
local TableField = require "reflect.injection.TableField"

local typeof_LuaBehaviour = typeof(CS.Nianxie.Components.LuaBehaviour)
local typeof_LuafabLoading = typeof(CS.Nianxie.Framework.LuafabLoading)

local ClassCore = require "reflect.injection.ClassCore"

;
      


local ReflectInjection = {}

function ReflectInjection.new(vKey, vClsOpen, vCSharpType, vIndexCSharpType, vNodePath, vAssetPath, vNodePathTable , vAssetPathTable )
       
         
    
         
    

    return {
        key=vKey,
        clsOpen=vClsOpen,
        nodePath=vNodePath,
        assetPath=vAssetPath,
        nodePathTable=vNodePathTable,
        assetPathTable=vAssetPathTable,
        lazy=false,
        table=false,
        indexType=vIndexCSharpType,
        csharpType=vCSharpType,
        __injectionType=nil,
    }
end

function ReflectInjection.compare(vLeftInjection, vRightInjection)
    return vLeftInjection.key < vRightInjection.key
end

local function recursiveEvalNodePath(vNodePath , vKeyToFieldDefine    , vDepth)
    if vDepth > 5 then
        print("ERROR: node path eval $ too deep : "..tostring(vNodePath))
        return "?"
    end
    if vNodePath then
        local ret = vNodePath:gsub("^[$]([^/]+)", function(key)
            local fieldDefine = vKeyToFieldDefine[key]
            if not fieldDefine then
                return "$"..key
            end
            return recursiveEvalNodePath(fieldDefine[2], vKeyToFieldDefine, vDepth + 1) or "?"
        end)
        return ret
    else
        return nil
    end
end

function ReflectInjection.Create(vKeyToTuple, vKey, vFieldOrTuple)
    local outMeta = getmetatable(vFieldOrTuple)
    local fieldValue = outMeta and vFieldOrTuple or vFieldOrTuple[1]
    local nodePath=nil
    local assetPath=nil
    local nodePathTable=nil 
    local assetPathTable=nil 
    if not outMeta then
        if type(vFieldOrTuple) == "table" then
            do
                local tuple2 = vFieldOrTuple[2]
                local tuple3 = vFieldOrTuple[3]
                if type(tuple2) == "string" then
                    tuple2 = recursiveEvalNodePath(tuple2, vKeyToTuple, 1)
                elseif type(tuple2) == "table" then
                    for k,v in pairs(tuple2) do
                        tuple2[k] = recursiveEvalNodePath(v, vKeyToTuple, 1)
                    ::continue:: end
                end
                if type(tuple2) == "table" then
                    nodePathTable = tuple2
                else
                    nodePath = tuple2
                end
                if type(tuple3) == "table" then
                    assetPathTable = tuple3
                else
                    assetPath = tuple3
                end
            end
        else
            error("tuple not allow here")
        end
    end
    local valueMeta = getmetatable(fieldValue)
    if LuafabField.is(fieldValue) then
        local injection = ReflectInjection.new(vKey, fieldValue.clsOpen, typeof_LuafabLoading, nil, nil, fieldValue.assetPath)
        injection.lazy = fieldValue.lazy
        return injection
    elseif TableField.is(fieldValue) then
        local clsOpen, csharpType = ReflectInjection.checkClsOpenAndCSharpType(fieldValue.value)
        local key = fieldValue.key
        local injection = ReflectInjection.new(vKey, clsOpen, csharpType, key and typeof(key), nodePath, assetPath, nodePathTable, assetPathTable)
        injection.table = true
        return injection
    else
        local clsOpen, csharpType = ReflectInjection.checkClsOpenAndCSharpType(fieldValue, valueMeta)
        if clsOpen then
            local injection = ReflectInjection.new(vKey, clsOpen, csharpType, nil, nodePath, assetPath)
            return injection
        else
            return ReflectInjection.new(vKey, nil, csharpType, nil, nodePath, assetPath)
        end
    end
end

function ReflectInjection.checkClsOpenAndCSharpType(fieldValue, fieldMeta)
    local fieldMeta = fieldMeta or getmetatable(fieldValue)
    if ClassCore.meta == fieldMeta then
        return fieldValue, typeof_LuaBehaviour
    else
        local ok, csharpType = pcall(typeof, fieldValue)
        if not ok then
            error("type expected:"..csharpType)
        else
            return nil, csharpType
        end
    end
end


return ReflectInjection
end end
--reflect.injection.ReflectInjection end ==========)

--reflect.injection.TableField begin ==========(
do local _ENV = _ENV
packages['reflect.injection.TableField'] = function (...)

;
      


local TableField = {}
TableField.__index=TableField

;
      
         
            
            
         
    


function TableField.new (vValue, vKey)
     

    return setmetatable({
        key=vKey,
        value=vValue,
    }, TableField)
end

function TableField.is(v)
    return getmetatable(v) == TableField
end

;
     
          
              
        
             
        
    


return TableField
end end
--reflect.injection.TableField end ==========)

--reflect.reflect begin ==========(
do local _ENV = _ENV
packages['reflect.reflect'] = function (...)

if false then 
	  
	 
	local rapidjson = require "rapidjson"
    local arraymeta = getmetatable(rapidjson.array())
    local objectmeta = getmetatable(rapidjson.object())
    local unsafearray = rapidjson.array
    rapidjson.array = function(t)
        if getmetatable(t) == objectmeta then
            return setmetatable(t, arraymeta)
        else
            return unsafearray(t)
        end
    end
    local unsafeobject = rapidjson.object
    rapidjson.object = function(t)
        if getmetatable(t) == arraymeta then
            return setmetatable(t, objectmeta)
        else
            return unsafeobject(t)
        end
    end
end

local class = require  "reflect.class"

local ReflectInjection = require "reflect.injection.ReflectInjection"
local LuafabField = require "reflect.injection.LuafabField"
local TableField = require "reflect.injection.TableField"

local reflect = {}
reflect.class = class

;
      
            
            
            
            
            
    
       
             
                
                  
            
                     
                  
            
        
    


local MiniScript = require "reflect.behav.MiniScript"


function reflect._saveInjections(vClsOpen, vKeyToInjectionValue)
    local nInjectionList = vClsOpen.meta.__injections
    for nKey, nInjectionValue in pairs(vKeyToInjectionValue) do
        local nInjection = ReflectInjection.Create(vKeyToInjectionValue, nKey, nInjectionValue)
        nInjectionList[#nInjectionList + 1] = nInjection
    ::continue:: end
    table.sort(nInjectionList, ReflectInjection.compare)
end

function reflect.MiniScript (vKeyToInjectionValue)
    local clsOpen = class   (MiniScript)
    reflect._saveInjections(clsOpen, vKeyToInjectionValue)
    clsOpen.ctor = false  
           
         
           
        
         
            
          
            
        
    
    return clsOpen
end

function reflect.lazyLuafab(clsPath)
    local clsOpen = require(clsPath)
    return LuafabField.new (clsOpen, clsPath, true)
end

function reflect.readyLuafab(clsPath)
    local clsOpen = require(clsPath)
    return LuafabField.new (clsOpen, clsPath, false)
end

function reflect.Dict(key, value)
    return TableField.new (value, key)
end

function reflect.List(value)
    return TableField.new (value, nil)
end

function reflect.Any()
    return nil
end

return reflect

end end
--reflect.reflect end ==========)

package.preload["reflect.reflect"] = packages["reflect.reflect"]
package.preload["reflect.class"] = packages["reflect.class"]
package.preload["reflect"] = function()
    return require "reflect.reflect"
end
package.preload["class"] = function()
    return require "reflect.class"
end
return packages["boot.boot"]()
